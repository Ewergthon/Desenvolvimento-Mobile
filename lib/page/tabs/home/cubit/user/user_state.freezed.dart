// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$UserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserStateCopyWith<$Res> {
  factory $UserStateCopyWith(UserState value, $Res Function(UserState) then) =
      _$UserStateCopyWithImpl<$Res, UserState>;
}

/// @nodoc
class _$UserStateCopyWithImpl<$Res, $Val extends UserState>
    implements $UserStateCopyWith<$Res> {
  _$UserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialUserStateImplCopyWith<$Res> {
  factory _$$InitialUserStateImplCopyWith(_$InitialUserStateImpl value,
          $Res Function(_$InitialUserStateImpl) then) =
      __$$InitialUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$InitialUserStateImpl>
    implements _$$InitialUserStateImplCopyWith<$Res> {
  __$$InitialUserStateImplCopyWithImpl(_$InitialUserStateImpl _value,
      $Res Function(_$InitialUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialUserStateImpl implements InitialUserState {
  const _$InitialUserStateImpl();

  @override
  String toString() {
    return 'UserState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialUserState implements UserState {
  const factory InitialUserState() = _$InitialUserStateImpl;
}

/// @nodoc
abstract class _$$LoadingUserStateImplCopyWith<$Res> {
  factory _$$LoadingUserStateImplCopyWith(_$LoadingUserStateImpl value,
          $Res Function(_$LoadingUserStateImpl) then) =
      __$$LoadingUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$LoadingUserStateImpl>
    implements _$$LoadingUserStateImplCopyWith<$Res> {
  __$$LoadingUserStateImplCopyWithImpl(_$LoadingUserStateImpl _value,
      $Res Function(_$LoadingUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingUserStateImpl implements LoadingUserState {
  const _$LoadingUserStateImpl();

  @override
  String toString() {
    return 'UserState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingUserState implements UserState {
  const factory LoadingUserState() = _$LoadingUserStateImpl;
}

/// @nodoc
abstract class _$$SignOutLoadingUserStateImplCopyWith<$Res> {
  factory _$$SignOutLoadingUserStateImplCopyWith(
          _$SignOutLoadingUserStateImpl value,
          $Res Function(_$SignOutLoadingUserStateImpl) then) =
      __$$SignOutLoadingUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignOutLoadingUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$SignOutLoadingUserStateImpl>
    implements _$$SignOutLoadingUserStateImplCopyWith<$Res> {
  __$$SignOutLoadingUserStateImplCopyWithImpl(
      _$SignOutLoadingUserStateImpl _value,
      $Res Function(_$SignOutLoadingUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignOutLoadingUserStateImpl implements SignOutLoadingUserState {
  const _$SignOutLoadingUserStateImpl();

  @override
  String toString() {
    return 'UserState.loadingSignOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignOutLoadingUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return loadingSignOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return loadingSignOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (loadingSignOut != null) {
      return loadingSignOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return loadingSignOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return loadingSignOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (loadingSignOut != null) {
      return loadingSignOut(this);
    }
    return orElse();
  }
}

abstract class SignOutLoadingUserState implements UserState {
  const factory SignOutLoadingUserState() = _$SignOutLoadingUserStateImpl;
}

/// @nodoc
abstract class _$$SignOutErrprUserStateImplCopyWith<$Res> {
  factory _$$SignOutErrprUserStateImplCopyWith(
          _$SignOutErrprUserStateImpl value,
          $Res Function(_$SignOutErrprUserStateImpl) then) =
      __$$SignOutErrprUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignOutErrprUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$SignOutErrprUserStateImpl>
    implements _$$SignOutErrprUserStateImplCopyWith<$Res> {
  __$$SignOutErrprUserStateImplCopyWithImpl(_$SignOutErrprUserStateImpl _value,
      $Res Function(_$SignOutErrprUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignOutErrprUserStateImpl implements SignOutErrprUserState {
  const _$SignOutErrprUserStateImpl();

  @override
  String toString() {
    return 'UserState.errorSignOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignOutErrprUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return errorSignOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return errorSignOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (errorSignOut != null) {
      return errorSignOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return errorSignOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return errorSignOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (errorSignOut != null) {
      return errorSignOut(this);
    }
    return orElse();
  }
}

abstract class SignOutErrprUserState implements UserState {
  const factory SignOutErrprUserState() = _$SignOutErrprUserStateImpl;
}

/// @nodoc
abstract class _$$SignOutSuccessUserStateImplCopyWith<$Res> {
  factory _$$SignOutSuccessUserStateImplCopyWith(
          _$SignOutSuccessUserStateImpl value,
          $Res Function(_$SignOutSuccessUserStateImpl) then) =
      __$$SignOutSuccessUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignOutSuccessUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$SignOutSuccessUserStateImpl>
    implements _$$SignOutSuccessUserStateImplCopyWith<$Res> {
  __$$SignOutSuccessUserStateImplCopyWithImpl(
      _$SignOutSuccessUserStateImpl _value,
      $Res Function(_$SignOutSuccessUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignOutSuccessUserStateImpl implements SignOutSuccessUserState {
  const _$SignOutSuccessUserStateImpl();

  @override
  String toString() {
    return 'UserState.successSignOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignOutSuccessUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return successSignOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return successSignOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (successSignOut != null) {
      return successSignOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return successSignOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return successSignOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (successSignOut != null) {
      return successSignOut(this);
    }
    return orElse();
  }
}

abstract class SignOutSuccessUserState implements UserState {
  const factory SignOutSuccessUserState() = _$SignOutSuccessUserStateImpl;
}

/// @nodoc
abstract class _$$SuccessSetUserStateImplCopyWith<$Res> {
  factory _$$SuccessSetUserStateImplCopyWith(_$SuccessSetUserStateImpl value,
          $Res Function(_$SuccessSetUserStateImpl) then) =
      __$$SuccessSetUserStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuccessSetUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$SuccessSetUserStateImpl>
    implements _$$SuccessSetUserStateImplCopyWith<$Res> {
  __$$SuccessSetUserStateImplCopyWithImpl(_$SuccessSetUserStateImpl _value,
      $Res Function(_$SuccessSetUserStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SuccessSetUserStateImpl implements SuccessSetUserState {
  const _$SuccessSetUserStateImpl();

  @override
  String toString() {
    return 'UserState.setSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessSetUserStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return setSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return setSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (setSuccess != null) {
      return setSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return setSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return setSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (setSuccess != null) {
      return setSuccess(this);
    }
    return orElse();
  }
}

abstract class SuccessSetUserState implements UserState {
  const factory SuccessSetUserState() = _$SuccessSetUserStateImpl;
}

/// @nodoc
abstract class _$$SuccessUserStateImplCopyWith<$Res> {
  factory _$$SuccessUserStateImplCopyWith(_$SuccessUserStateImpl value,
          $Res Function(_$SuccessUserStateImpl) then) =
      __$$SuccessUserStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserDto user});

  $UserDtoCopyWith<$Res> get user;
}

/// @nodoc
class __$$SuccessUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$SuccessUserStateImpl>
    implements _$$SuccessUserStateImplCopyWith<$Res> {
  __$$SuccessUserStateImplCopyWithImpl(_$SuccessUserStateImpl _value,
      $Res Function(_$SuccessUserStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = null,
  }) {
    return _then(_$SuccessUserStateImpl(
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserDto,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $UserDtoCopyWith<$Res> get user {
    return $UserDtoCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value));
    });
  }
}

/// @nodoc

class _$SuccessUserStateImpl implements SuccessUserState {
  const _$SuccessUserStateImpl({required this.user});

  @override
  final UserDto user;

  @override
  String toString() {
    return 'UserState.success(user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessUserStateImpl &&
            (identical(other.user, user) || other.user == user));
  }

  @override
  int get hashCode => Object.hash(runtimeType, user);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessUserStateImplCopyWith<_$SuccessUserStateImpl> get copyWith =>
      __$$SuccessUserStateImplCopyWithImpl<_$SuccessUserStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return success(user);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return success?.call(user);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(user);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class SuccessUserState implements UserState {
  const factory SuccessUserState({required final UserDto user}) =
      _$SuccessUserStateImpl;

  UserDto get user;
  @JsonKey(ignore: true)
  _$$SuccessUserStateImplCopyWith<_$SuccessUserStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorUserStateImplCopyWith<$Res> {
  factory _$$ErrorUserStateImplCopyWith(_$ErrorUserStateImpl value,
          $Res Function(_$ErrorUserStateImpl) then) =
      __$$ErrorUserStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace stackTrace, bool shouldPopPage});
}

/// @nodoc
class __$$ErrorUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$ErrorUserStateImpl>
    implements _$$ErrorUserStateImplCopyWith<$Res> {
  __$$ErrorUserStateImplCopyWithImpl(
      _$ErrorUserStateImpl _value, $Res Function(_$ErrorUserStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$ErrorUserStateImpl(
      exception: null == exception ? _value.exception : exception,
      stackTrace: null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ErrorUserStateImpl implements ErrorUserState {
  const _$ErrorUserStateImpl(
      {required this.exception,
      required this.stackTrace,
      required this.shouldPopPage});

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'UserState.error(exception: $exception, stackTrace: $stackTrace, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorUserStateImpl &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(exception),
      stackTrace,
      shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorUserStateImplCopyWith<_$ErrorUserStateImpl> get copyWith =>
      __$$ErrorUserStateImplCopyWithImpl<_$ErrorUserStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return error(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return error?.call(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(exception, stackTrace, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorUserState implements UserState {
  const factory ErrorUserState(
      {required final Object exception,
      required final StackTrace stackTrace,
      required final bool shouldPopPage}) = _$ErrorUserStateImpl;

  Object get exception;
  StackTrace get stackTrace;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$ErrorUserStateImplCopyWith<_$ErrorUserStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OfflineUserStateImplCopyWith<$Res> {
  factory _$$OfflineUserStateImplCopyWith(_$OfflineUserStateImpl value,
          $Res Function(_$OfflineUserStateImpl) then) =
      __$$OfflineUserStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic Function() onTryAgain, bool shouldPopPage});
}

/// @nodoc
class __$$OfflineUserStateImplCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$OfflineUserStateImpl>
    implements _$$OfflineUserStateImplCopyWith<$Res> {
  __$$OfflineUserStateImplCopyWithImpl(_$OfflineUserStateImpl _value,
      $Res Function(_$OfflineUserStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onTryAgain = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$OfflineUserStateImpl(
      onTryAgain: null == onTryAgain
          ? _value.onTryAgain
          : onTryAgain // ignore: cast_nullable_to_non_nullable
              as dynamic Function(),
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$OfflineUserStateImpl implements OfflineUserState {
  const _$OfflineUserStateImpl(
      {required this.onTryAgain, required this.shouldPopPage});

  @override
  final dynamic Function() onTryAgain;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'UserState.offline(onTryAgain: $onTryAgain, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineUserStateImpl &&
            (identical(other.onTryAgain, onTryAgain) ||
                other.onTryAgain == onTryAgain) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onTryAgain, shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineUserStateImplCopyWith<_$OfflineUserStateImpl> get copyWith =>
      __$$OfflineUserStateImplCopyWithImpl<_$OfflineUserStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loadingSignOut,
    required TResult Function() errorSignOut,
    required TResult Function() successSignOut,
    required TResult Function() setSuccess,
    required TResult Function(UserDto user) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return offline(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loadingSignOut,
    TResult? Function()? errorSignOut,
    TResult? Function()? successSignOut,
    TResult? Function()? setSuccess,
    TResult? Function(UserDto user)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return offline?.call(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loadingSignOut,
    TResult Function()? errorSignOut,
    TResult Function()? successSignOut,
    TResult Function()? setSuccess,
    TResult Function(UserDto user)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(onTryAgain, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialUserState value) initial,
    required TResult Function(LoadingUserState value) loading,
    required TResult Function(SignOutLoadingUserState value) loadingSignOut,
    required TResult Function(SignOutErrprUserState value) errorSignOut,
    required TResult Function(SignOutSuccessUserState value) successSignOut,
    required TResult Function(SuccessSetUserState value) setSuccess,
    required TResult Function(SuccessUserState value) success,
    required TResult Function(ErrorUserState value) error,
    required TResult Function(OfflineUserState value) offline,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialUserState value)? initial,
    TResult? Function(LoadingUserState value)? loading,
    TResult? Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult? Function(SignOutErrprUserState value)? errorSignOut,
    TResult? Function(SignOutSuccessUserState value)? successSignOut,
    TResult? Function(SuccessSetUserState value)? setSuccess,
    TResult? Function(SuccessUserState value)? success,
    TResult? Function(ErrorUserState value)? error,
    TResult? Function(OfflineUserState value)? offline,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialUserState value)? initial,
    TResult Function(LoadingUserState value)? loading,
    TResult Function(SignOutLoadingUserState value)? loadingSignOut,
    TResult Function(SignOutErrprUserState value)? errorSignOut,
    TResult Function(SignOutSuccessUserState value)? successSignOut,
    TResult Function(SuccessSetUserState value)? setSuccess,
    TResult Function(SuccessUserState value)? success,
    TResult Function(ErrorUserState value)? error,
    TResult Function(OfflineUserState value)? offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class OfflineUserState implements UserState {
  const factory OfflineUserState(
      {required final dynamic Function() onTryAgain,
      required final bool shouldPopPage}) = _$OfflineUserStateImpl;

  dynamic Function() get onTryAgain;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$OfflineUserStateImplCopyWith<_$OfflineUserStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
