// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialHomeStateImplCopyWith<$Res> {
  factory _$$InitialHomeStateImplCopyWith(_$InitialHomeStateImpl value,
          $Res Function(_$InitialHomeStateImpl) then) =
      __$$InitialHomeStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$InitialHomeStateImpl>
    implements _$$InitialHomeStateImplCopyWith<$Res> {
  __$$InitialHomeStateImplCopyWithImpl(_$InitialHomeStateImpl _value,
      $Res Function(_$InitialHomeStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialHomeStateImpl implements InitialHomeState {
  const _$InitialHomeStateImpl();

  @override
  String toString() {
    return 'HomeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialHomeStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialHomeState implements HomeState {
  const factory InitialHomeState() = _$InitialHomeStateImpl;
}

/// @nodoc
abstract class _$$LoadingHomeStateImplCopyWith<$Res> {
  factory _$$LoadingHomeStateImplCopyWith(_$LoadingHomeStateImpl value,
          $Res Function(_$LoadingHomeStateImpl) then) =
      __$$LoadingHomeStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$LoadingHomeStateImpl>
    implements _$$LoadingHomeStateImplCopyWith<$Res> {
  __$$LoadingHomeStateImplCopyWithImpl(_$LoadingHomeStateImpl _value,
      $Res Function(_$LoadingHomeStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingHomeStateImpl implements LoadingHomeState {
  const _$LoadingHomeStateImpl();

  @override
  String toString() {
    return 'HomeState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingHomeStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingHomeState implements HomeState {
  const factory LoadingHomeState() = _$LoadingHomeStateImpl;
}

/// @nodoc
abstract class _$$EmptyHomeStateImplCopyWith<$Res> {
  factory _$$EmptyHomeStateImplCopyWith(_$EmptyHomeStateImpl value,
          $Res Function(_$EmptyHomeStateImpl) then) =
      __$$EmptyHomeStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmptyHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$EmptyHomeStateImpl>
    implements _$$EmptyHomeStateImplCopyWith<$Res> {
  __$$EmptyHomeStateImplCopyWithImpl(
      _$EmptyHomeStateImpl _value, $Res Function(_$EmptyHomeStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmptyHomeStateImpl implements EmptyHomeState {
  const _$EmptyHomeStateImpl();

  @override
  String toString() {
    return 'HomeState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyHomeStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyHomeState implements HomeState {
  const factory EmptyHomeState() = _$EmptyHomeStateImpl;
}

/// @nodoc
abstract class _$$UserRemovedHomeStateImplCopyWith<$Res> {
  factory _$$UserRemovedHomeStateImplCopyWith(_$UserRemovedHomeStateImpl value,
          $Res Function(_$UserRemovedHomeStateImpl) then) =
      __$$UserRemovedHomeStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserRemovedHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$UserRemovedHomeStateImpl>
    implements _$$UserRemovedHomeStateImplCopyWith<$Res> {
  __$$UserRemovedHomeStateImplCopyWithImpl(_$UserRemovedHomeStateImpl _value,
      $Res Function(_$UserRemovedHomeStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserRemovedHomeStateImpl implements UserRemovedHomeState {
  const _$UserRemovedHomeStateImpl();

  @override
  String toString() {
    return 'HomeState.userRemoved()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserRemovedHomeStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return userRemoved();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return userRemoved?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (userRemoved != null) {
      return userRemoved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return userRemoved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return userRemoved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (userRemoved != null) {
      return userRemoved(this);
    }
    return orElse();
  }
}

abstract class UserRemovedHomeState implements HomeState {
  const factory UserRemovedHomeState() = _$UserRemovedHomeStateImpl;
}

/// @nodoc
abstract class _$$BookSuccessStateImplCopyWith<$Res> {
  factory _$$BookSuccessStateImplCopyWith(_$BookSuccessStateImpl value,
          $Res Function(_$BookSuccessStateImpl) then) =
      __$$BookSuccessStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookSuccessStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$BookSuccessStateImpl>
    implements _$$BookSuccessStateImplCopyWith<$Res> {
  __$$BookSuccessStateImplCopyWithImpl(_$BookSuccessStateImpl _value,
      $Res Function(_$BookSuccessStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookSuccessStateImpl implements BookSuccessState {
  const _$BookSuccessStateImpl();

  @override
  String toString() {
    return 'HomeState.bookSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BookSuccessStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return bookSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return bookSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (bookSuccess != null) {
      return bookSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return bookSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return bookSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (bookSuccess != null) {
      return bookSuccess(this);
    }
    return orElse();
  }
}

abstract class BookSuccessState implements HomeState {
  const factory BookSuccessState() = _$BookSuccessStateImpl;
}

/// @nodoc
abstract class _$$BookLoadingStateImplCopyWith<$Res> {
  factory _$$BookLoadingStateImplCopyWith(_$BookLoadingStateImpl value,
          $Res Function(_$BookLoadingStateImpl) then) =
      __$$BookLoadingStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookLoadingStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$BookLoadingStateImpl>
    implements _$$BookLoadingStateImplCopyWith<$Res> {
  __$$BookLoadingStateImplCopyWithImpl(_$BookLoadingStateImpl _value,
      $Res Function(_$BookLoadingStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookLoadingStateImpl implements BookLoadingState {
  const _$BookLoadingStateImpl();

  @override
  String toString() {
    return 'HomeState.bookLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BookLoadingStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return bookLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return bookLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (bookLoading != null) {
      return bookLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return bookLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return bookLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (bookLoading != null) {
      return bookLoading(this);
    }
    return orElse();
  }
}

abstract class BookLoadingState implements HomeState {
  const factory BookLoadingState() = _$BookLoadingStateImpl;
}

/// @nodoc
abstract class _$$BookErrorStateImplCopyWith<$Res> {
  factory _$$BookErrorStateImplCopyWith(_$BookErrorStateImpl value,
          $Res Function(_$BookErrorStateImpl) then) =
      __$$BookErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace stackTrace});
}

/// @nodoc
class __$$BookErrorStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$BookErrorStateImpl>
    implements _$$BookErrorStateImplCopyWith<$Res> {
  __$$BookErrorStateImplCopyWithImpl(
      _$BookErrorStateImpl _value, $Res Function(_$BookErrorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
  }) {
    return _then(_$BookErrorStateImpl(
      exception: null == exception ? _value.exception : exception,
      stackTrace: null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$BookErrorStateImpl implements BookErrorState {
  const _$BookErrorStateImpl(
      {required this.exception, required this.stackTrace});

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;

  @override
  String toString() {
    return 'HomeState.bookError(exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookErrorStateImpl &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(exception), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookErrorStateImplCopyWith<_$BookErrorStateImpl> get copyWith =>
      __$$BookErrorStateImplCopyWithImpl<_$BookErrorStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return bookError(exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return bookError?.call(exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (bookError != null) {
      return bookError(exception, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return bookError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return bookError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (bookError != null) {
      return bookError(this);
    }
    return orElse();
  }
}

abstract class BookErrorState implements HomeState {
  const factory BookErrorState(
      {required final Object exception,
      required final StackTrace stackTrace}) = _$BookErrorStateImpl;

  Object get exception;
  StackTrace get stackTrace;
  @JsonKey(ignore: true)
  _$$BookErrorStateImplCopyWith<_$BookErrorStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessHomeStateImplCopyWith<$Res> {
  factory _$$SuccessHomeStateImplCopyWith(_$SuccessHomeStateImpl value,
          $Res Function(_$SuccessHomeStateImpl) then) =
      __$$SuccessHomeStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<EventDto>? events});
}

/// @nodoc
class __$$SuccessHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SuccessHomeStateImpl>
    implements _$$SuccessHomeStateImplCopyWith<$Res> {
  __$$SuccessHomeStateImplCopyWithImpl(_$SuccessHomeStateImpl _value,
      $Res Function(_$SuccessHomeStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? events = freezed,
  }) {
    return _then(_$SuccessHomeStateImpl(
      events: freezed == events
          ? _value._events
          : events // ignore: cast_nullable_to_non_nullable
              as List<EventDto>?,
    ));
  }
}

/// @nodoc

class _$SuccessHomeStateImpl implements SuccessHomeState {
  const _$SuccessHomeStateImpl({required final List<EventDto>? events})
      : _events = events;

  final List<EventDto>? _events;
  @override
  List<EventDto>? get events {
    final value = _events;
    if (value == null) return null;
    if (_events is EqualUnmodifiableListView) return _events;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'HomeState.success(events: $events)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessHomeStateImpl &&
            const DeepCollectionEquality().equals(other._events, _events));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_events));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessHomeStateImplCopyWith<_$SuccessHomeStateImpl> get copyWith =>
      __$$SuccessHomeStateImplCopyWithImpl<_$SuccessHomeStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return success(events);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return success?.call(events);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(events);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class SuccessHomeState implements HomeState {
  const factory SuccessHomeState({required final List<EventDto>? events}) =
      _$SuccessHomeStateImpl;

  List<EventDto>? get events;
  @JsonKey(ignore: true)
  _$$SuccessHomeStateImplCopyWith<_$SuccessHomeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorHomeStateImplCopyWith<$Res> {
  factory _$$ErrorHomeStateImplCopyWith(_$ErrorHomeStateImpl value,
          $Res Function(_$ErrorHomeStateImpl) then) =
      __$$ErrorHomeStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace stackTrace, bool shouldPopPage});
}

/// @nodoc
class __$$ErrorHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$ErrorHomeStateImpl>
    implements _$$ErrorHomeStateImplCopyWith<$Res> {
  __$$ErrorHomeStateImplCopyWithImpl(
      _$ErrorHomeStateImpl _value, $Res Function(_$ErrorHomeStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$ErrorHomeStateImpl(
      exception: null == exception ? _value.exception : exception,
      stackTrace: null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ErrorHomeStateImpl implements ErrorHomeState {
  const _$ErrorHomeStateImpl(
      {required this.exception,
      required this.stackTrace,
      required this.shouldPopPage});

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'HomeState.error(exception: $exception, stackTrace: $stackTrace, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorHomeStateImpl &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(exception),
      stackTrace,
      shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorHomeStateImplCopyWith<_$ErrorHomeStateImpl> get copyWith =>
      __$$ErrorHomeStateImplCopyWithImpl<_$ErrorHomeStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return error(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return error?.call(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(exception, stackTrace, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorHomeState implements HomeState {
  const factory ErrorHomeState(
      {required final Object exception,
      required final StackTrace stackTrace,
      required final bool shouldPopPage}) = _$ErrorHomeStateImpl;

  Object get exception;
  StackTrace get stackTrace;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$ErrorHomeStateImplCopyWith<_$ErrorHomeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OfflineHomeStateImplCopyWith<$Res> {
  factory _$$OfflineHomeStateImplCopyWith(_$OfflineHomeStateImpl value,
          $Res Function(_$OfflineHomeStateImpl) then) =
      __$$OfflineHomeStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic Function() onTryAgain, bool shouldPopPage});
}

/// @nodoc
class __$$OfflineHomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$OfflineHomeStateImpl>
    implements _$$OfflineHomeStateImplCopyWith<$Res> {
  __$$OfflineHomeStateImplCopyWithImpl(_$OfflineHomeStateImpl _value,
      $Res Function(_$OfflineHomeStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onTryAgain = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$OfflineHomeStateImpl(
      onTryAgain: null == onTryAgain
          ? _value.onTryAgain
          : onTryAgain // ignore: cast_nullable_to_non_nullable
              as dynamic Function(),
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$OfflineHomeStateImpl implements OfflineHomeState {
  const _$OfflineHomeStateImpl(
      {required this.onTryAgain, required this.shouldPopPage});

  @override
  final dynamic Function() onTryAgain;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'HomeState.offline(onTryAgain: $onTryAgain, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineHomeStateImpl &&
            (identical(other.onTryAgain, onTryAgain) ||
                other.onTryAgain == onTryAgain) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onTryAgain, shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineHomeStateImplCopyWith<_$OfflineHomeStateImpl> get copyWith =>
      __$$OfflineHomeStateImplCopyWithImpl<_$OfflineHomeStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() empty,
    required TResult Function() userRemoved,
    required TResult Function() bookSuccess,
    required TResult Function() bookLoading,
    required TResult Function(Object exception, StackTrace stackTrace)
        bookError,
    required TResult Function(List<EventDto>? events) success,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return offline(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? empty,
    TResult? Function()? userRemoved,
    TResult? Function()? bookSuccess,
    TResult? Function()? bookLoading,
    TResult? Function(Object exception, StackTrace stackTrace)? bookError,
    TResult? Function(List<EventDto>? events)? success,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return offline?.call(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? empty,
    TResult Function()? userRemoved,
    TResult Function()? bookSuccess,
    TResult Function()? bookLoading,
    TResult Function(Object exception, StackTrace stackTrace)? bookError,
    TResult Function(List<EventDto>? events)? success,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(onTryAgain, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialHomeState value) initial,
    required TResult Function(LoadingHomeState value) loading,
    required TResult Function(EmptyHomeState value) empty,
    required TResult Function(UserRemovedHomeState value) userRemoved,
    required TResult Function(BookSuccessState value) bookSuccess,
    required TResult Function(BookLoadingState value) bookLoading,
    required TResult Function(BookErrorState value) bookError,
    required TResult Function(SuccessHomeState value) success,
    required TResult Function(ErrorHomeState value) error,
    required TResult Function(OfflineHomeState value) offline,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialHomeState value)? initial,
    TResult? Function(LoadingHomeState value)? loading,
    TResult? Function(EmptyHomeState value)? empty,
    TResult? Function(UserRemovedHomeState value)? userRemoved,
    TResult? Function(BookSuccessState value)? bookSuccess,
    TResult? Function(BookLoadingState value)? bookLoading,
    TResult? Function(BookErrorState value)? bookError,
    TResult? Function(SuccessHomeState value)? success,
    TResult? Function(ErrorHomeState value)? error,
    TResult? Function(OfflineHomeState value)? offline,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialHomeState value)? initial,
    TResult Function(LoadingHomeState value)? loading,
    TResult Function(EmptyHomeState value)? empty,
    TResult Function(UserRemovedHomeState value)? userRemoved,
    TResult Function(BookSuccessState value)? bookSuccess,
    TResult Function(BookLoadingState value)? bookLoading,
    TResult Function(BookErrorState value)? bookError,
    TResult Function(SuccessHomeState value)? success,
    TResult Function(ErrorHomeState value)? error,
    TResult Function(OfflineHomeState value)? offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class OfflineHomeState implements HomeState {
  const factory OfflineHomeState(
      {required final dynamic Function() onTryAgain,
      required final bool shouldPopPage}) = _$OfflineHomeStateImpl;

  dynamic Function() get onTryAgain;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$OfflineHomeStateImplCopyWith<_$OfflineHomeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
