// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ticket_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TicketState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TicketStateCopyWith<$Res> {
  factory $TicketStateCopyWith(
          TicketState value, $Res Function(TicketState) then) =
      _$TicketStateCopyWithImpl<$Res, TicketState>;
}

/// @nodoc
class _$TicketStateCopyWithImpl<$Res, $Val extends TicketState>
    implements $TicketStateCopyWith<$Res> {
  _$TicketStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialTicketStateImplCopyWith<$Res> {
  factory _$$InitialTicketStateImplCopyWith(_$InitialTicketStateImpl value,
          $Res Function(_$InitialTicketStateImpl) then) =
      __$$InitialTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$InitialTicketStateImpl>
    implements _$$InitialTicketStateImplCopyWith<$Res> {
  __$$InitialTicketStateImplCopyWithImpl(_$InitialTicketStateImpl _value,
      $Res Function(_$InitialTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialTicketStateImpl implements InitialTicketState {
  const _$InitialTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialTicketState implements TicketState {
  const factory InitialTicketState() = _$InitialTicketStateImpl;
}

/// @nodoc
abstract class _$$LoadingTicketStateImplCopyWith<$Res> {
  factory _$$LoadingTicketStateImplCopyWith(_$LoadingTicketStateImpl value,
          $Res Function(_$LoadingTicketStateImpl) then) =
      __$$LoadingTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$LoadingTicketStateImpl>
    implements _$$LoadingTicketStateImplCopyWith<$Res> {
  __$$LoadingTicketStateImplCopyWithImpl(_$LoadingTicketStateImpl _value,
      $Res Function(_$LoadingTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingTicketStateImpl implements LoadingTicketState {
  const _$LoadingTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingTicketState implements TicketState {
  const factory LoadingTicketState() = _$LoadingTicketStateImpl;
}

/// @nodoc
abstract class _$$HaveTicketStateImplCopyWith<$Res> {
  factory _$$HaveTicketStateImplCopyWith(_$HaveTicketStateImpl value,
          $Res Function(_$HaveTicketStateImpl) then) =
      __$$HaveTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HaveTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$HaveTicketStateImpl>
    implements _$$HaveTicketStateImplCopyWith<$Res> {
  __$$HaveTicketStateImplCopyWithImpl(
      _$HaveTicketStateImpl _value, $Res Function(_$HaveTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HaveTicketStateImpl implements HaveTicketState {
  const _$HaveTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.haveTicket()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HaveTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return haveTicket();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return haveTicket?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (haveTicket != null) {
      return haveTicket();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return haveTicket(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return haveTicket?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (haveTicket != null) {
      return haveTicket(this);
    }
    return orElse();
  }
}

abstract class HaveTicketState implements TicketState {
  const factory HaveTicketState() = _$HaveTicketStateImpl;
}

/// @nodoc
abstract class _$$EmptyTicketStateImplCopyWith<$Res> {
  factory _$$EmptyTicketStateImplCopyWith(_$EmptyTicketStateImpl value,
          $Res Function(_$EmptyTicketStateImpl) then) =
      __$$EmptyTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmptyTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$EmptyTicketStateImpl>
    implements _$$EmptyTicketStateImplCopyWith<$Res> {
  __$$EmptyTicketStateImplCopyWithImpl(_$EmptyTicketStateImpl _value,
      $Res Function(_$EmptyTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmptyTicketStateImpl implements EmptyTicketState {
  const _$EmptyTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyTicketState implements TicketState {
  const factory EmptyTicketState() = _$EmptyTicketStateImpl;
}

/// @nodoc
abstract class _$$SuccessTicketStateImplCopyWith<$Res> {
  factory _$$SuccessTicketStateImplCopyWith(_$SuccessTicketStateImpl value,
          $Res Function(_$SuccessTicketStateImpl) then) =
      __$$SuccessTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuccessTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$SuccessTicketStateImpl>
    implements _$$SuccessTicketStateImplCopyWith<$Res> {
  __$$SuccessTicketStateImplCopyWithImpl(_$SuccessTicketStateImpl _value,
      $Res Function(_$SuccessTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SuccessTicketStateImpl implements SuccessTicketState {
  const _$SuccessTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SuccessTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class SuccessTicketState implements TicketState {
  const factory SuccessTicketState() = _$SuccessTicketStateImpl;
}

/// @nodoc
abstract class _$$LoadedTicketStateImplCopyWith<$Res> {
  factory _$$LoadedTicketStateImplCopyWith(_$LoadedTicketStateImpl value,
          $Res Function(_$LoadedTicketStateImpl) then) =
      __$$LoadedTicketStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TicketDto? ticket});

  $TicketDtoCopyWith<$Res>? get ticket;
}

/// @nodoc
class __$$LoadedTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$LoadedTicketStateImpl>
    implements _$$LoadedTicketStateImplCopyWith<$Res> {
  __$$LoadedTicketStateImplCopyWithImpl(_$LoadedTicketStateImpl _value,
      $Res Function(_$LoadedTicketStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ticket = freezed,
  }) {
    return _then(_$LoadedTicketStateImpl(
      ticket: freezed == ticket
          ? _value.ticket
          : ticket // ignore: cast_nullable_to_non_nullable
              as TicketDto?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TicketDtoCopyWith<$Res>? get ticket {
    if (_value.ticket == null) {
      return null;
    }

    return $TicketDtoCopyWith<$Res>(_value.ticket!, (value) {
      return _then(_value.copyWith(ticket: value));
    });
  }
}

/// @nodoc

class _$LoadedTicketStateImpl implements LoadedTicketState {
  const _$LoadedTicketStateImpl({required this.ticket});

  @override
  final TicketDto? ticket;

  @override
  String toString() {
    return 'TicketState.ticketLoaded(ticket: $ticket)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedTicketStateImpl &&
            (identical(other.ticket, ticket) || other.ticket == ticket));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ticket);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedTicketStateImplCopyWith<_$LoadedTicketStateImpl> get copyWith =>
      __$$LoadedTicketStateImplCopyWithImpl<_$LoadedTicketStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return ticketLoaded(ticket);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return ticketLoaded?.call(ticket);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (ticketLoaded != null) {
      return ticketLoaded(ticket);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return ticketLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return ticketLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (ticketLoaded != null) {
      return ticketLoaded(this);
    }
    return orElse();
  }
}

abstract class LoadedTicketState implements TicketState {
  const factory LoadedTicketState({required final TicketDto? ticket}) =
      _$LoadedTicketStateImpl;

  TicketDto? get ticket;
  @JsonKey(ignore: true)
  _$$LoadedTicketStateImplCopyWith<_$LoadedTicketStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeletedTicketStateImplCopyWith<$Res> {
  factory _$$DeletedTicketStateImplCopyWith(_$DeletedTicketStateImpl value,
          $Res Function(_$DeletedTicketStateImpl) then) =
      __$$DeletedTicketStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DeletedTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$DeletedTicketStateImpl>
    implements _$$DeletedTicketStateImplCopyWith<$Res> {
  __$$DeletedTicketStateImplCopyWithImpl(_$DeletedTicketStateImpl _value,
      $Res Function(_$DeletedTicketStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DeletedTicketStateImpl implements DeletedTicketState {
  const _$DeletedTicketStateImpl();

  @override
  String toString() {
    return 'TicketState.deleted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DeletedTicketStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return deleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return deleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return deleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return deleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (deleted != null) {
      return deleted(this);
    }
    return orElse();
  }
}

abstract class DeletedTicketState implements TicketState {
  const factory DeletedTicketState() = _$DeletedTicketStateImpl;
}

/// @nodoc
abstract class _$$ErrorTicketStateImplCopyWith<$Res> {
  factory _$$ErrorTicketStateImplCopyWith(_$ErrorTicketStateImpl value,
          $Res Function(_$ErrorTicketStateImpl) then) =
      __$$ErrorTicketStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace stackTrace, bool shouldPopPage});
}

/// @nodoc
class __$$ErrorTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$ErrorTicketStateImpl>
    implements _$$ErrorTicketStateImplCopyWith<$Res> {
  __$$ErrorTicketStateImplCopyWithImpl(_$ErrorTicketStateImpl _value,
      $Res Function(_$ErrorTicketStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$ErrorTicketStateImpl(
      exception: null == exception ? _value.exception : exception,
      stackTrace: null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ErrorTicketStateImpl implements ErrorTicketState {
  const _$ErrorTicketStateImpl(
      {required this.exception,
      required this.stackTrace,
      required this.shouldPopPage});

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'TicketState.error(exception: $exception, stackTrace: $stackTrace, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorTicketStateImpl &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(exception),
      stackTrace,
      shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorTicketStateImplCopyWith<_$ErrorTicketStateImpl> get copyWith =>
      __$$ErrorTicketStateImplCopyWithImpl<_$ErrorTicketStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return error(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return error?.call(exception, stackTrace, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(exception, stackTrace, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorTicketState implements TicketState {
  const factory ErrorTicketState(
      {required final Object exception,
      required final StackTrace stackTrace,
      required final bool shouldPopPage}) = _$ErrorTicketStateImpl;

  Object get exception;
  StackTrace get stackTrace;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$ErrorTicketStateImplCopyWith<_$ErrorTicketStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OfflineTicketStateImplCopyWith<$Res> {
  factory _$$OfflineTicketStateImplCopyWith(_$OfflineTicketStateImpl value,
          $Res Function(_$OfflineTicketStateImpl) then) =
      __$$OfflineTicketStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic Function() onTryAgain, bool shouldPopPage});
}

/// @nodoc
class __$$OfflineTicketStateImplCopyWithImpl<$Res>
    extends _$TicketStateCopyWithImpl<$Res, _$OfflineTicketStateImpl>
    implements _$$OfflineTicketStateImplCopyWith<$Res> {
  __$$OfflineTicketStateImplCopyWithImpl(_$OfflineTicketStateImpl _value,
      $Res Function(_$OfflineTicketStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onTryAgain = null,
    Object? shouldPopPage = null,
  }) {
    return _then(_$OfflineTicketStateImpl(
      onTryAgain: null == onTryAgain
          ? _value.onTryAgain
          : onTryAgain // ignore: cast_nullable_to_non_nullable
              as dynamic Function(),
      shouldPopPage: null == shouldPopPage
          ? _value.shouldPopPage
          : shouldPopPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$OfflineTicketStateImpl implements OfflineTicketState {
  const _$OfflineTicketStateImpl(
      {required this.onTryAgain, required this.shouldPopPage});

  @override
  final dynamic Function() onTryAgain;
  @override
  final bool shouldPopPage;

  @override
  String toString() {
    return 'TicketState.offline(onTryAgain: $onTryAgain, shouldPopPage: $shouldPopPage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OfflineTicketStateImpl &&
            (identical(other.onTryAgain, onTryAgain) ||
                other.onTryAgain == onTryAgain) &&
            (identical(other.shouldPopPage, shouldPopPage) ||
                other.shouldPopPage == shouldPopPage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onTryAgain, shouldPopPage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OfflineTicketStateImplCopyWith<_$OfflineTicketStateImpl> get copyWith =>
      __$$OfflineTicketStateImplCopyWithImpl<_$OfflineTicketStateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() haveTicket,
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function(TicketDto? ticket) ticketLoaded,
    required TResult Function() deleted,
    required TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)
        error,
    required TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)
        offline,
  }) {
    return offline(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? haveTicket,
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function(TicketDto? ticket)? ticketLoaded,
    TResult? Function()? deleted,
    TResult? Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult? Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
  }) {
    return offline?.call(onTryAgain, shouldPopPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? haveTicket,
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function(TicketDto? ticket)? ticketLoaded,
    TResult Function()? deleted,
    TResult Function(
            Object exception, StackTrace stackTrace, bool shouldPopPage)?
        error,
    TResult Function(dynamic Function() onTryAgain, bool shouldPopPage)?
        offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(onTryAgain, shouldPopPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialTicketState value) initial,
    required TResult Function(LoadingTicketState value) loading,
    required TResult Function(HaveTicketState value) haveTicket,
    required TResult Function(EmptyTicketState value) empty,
    required TResult Function(SuccessTicketState value) success,
    required TResult Function(LoadedTicketState value) ticketLoaded,
    required TResult Function(DeletedTicketState value) deleted,
    required TResult Function(ErrorTicketState value) error,
    required TResult Function(OfflineTicketState value) offline,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialTicketState value)? initial,
    TResult? Function(LoadingTicketState value)? loading,
    TResult? Function(HaveTicketState value)? haveTicket,
    TResult? Function(EmptyTicketState value)? empty,
    TResult? Function(SuccessTicketState value)? success,
    TResult? Function(LoadedTicketState value)? ticketLoaded,
    TResult? Function(DeletedTicketState value)? deleted,
    TResult? Function(ErrorTicketState value)? error,
    TResult? Function(OfflineTicketState value)? offline,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialTicketState value)? initial,
    TResult Function(LoadingTicketState value)? loading,
    TResult Function(HaveTicketState value)? haveTicket,
    TResult Function(EmptyTicketState value)? empty,
    TResult Function(SuccessTicketState value)? success,
    TResult Function(LoadedTicketState value)? ticketLoaded,
    TResult Function(DeletedTicketState value)? deleted,
    TResult Function(ErrorTicketState value)? error,
    TResult Function(OfflineTicketState value)? offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class OfflineTicketState implements TicketState {
  const factory OfflineTicketState(
      {required final dynamic Function() onTryAgain,
      required final bool shouldPopPage}) = _$OfflineTicketStateImpl;

  dynamic Function() get onTryAgain;
  bool get shouldPopPage;
  @JsonKey(ignore: true)
  _$$OfflineTicketStateImplCopyWith<_$OfflineTicketStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
